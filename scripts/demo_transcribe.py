#!/usr/bin/env python3
import sys
import os
# Ensure project root is on PYTHONPATH
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
# Skip loading .env so we don't pick up DATABASE_URL pointing to Postgres
os.environ["SKIP_DOTENV"] = "1"
# Override the database URL to use an in-memory SQLite for demo purposes
os.environ["DATABASE_URL"] = "sqlite:///:memory:"
# Provide a dummy OpenAI API key for the demo if not set, to avoid ValueError
if not os.getenv("OPENAI_API_KEY"):
    print("Warning: OPENAI_API_KEY not found in environment. Using a dummy key for demo.")
    print("Summaries will be generated by a mock and may not be meaningful.")
    print("Set your actual OPENAI_API_KEY in .env for real summaries.")
    os.environ["OPENAI_API_KEY"] = "sk-dummykeyforlocaltestingonly12345"

try:
    import json
    from pathlib import Path
    from app.db import Base, engine, SessionLocal
    from app.models import Recording
    from app.summarizer import run_transcription_job, AUDIO_DIR # generate_summary is part of this job
    from sqlalchemy import create_engine # Keep this for explicit engine override
    from sqlalchemy.pool import StaticPool
    from sqlalchemy.orm import sessionmaker
except ImportError as e:
    print(f"Error importing required modules: {e}")
    print("\nTry running this script with your virtual environment Python:")
    print("source .venv/bin/activate  # Activate your venv first")
    print("python scripts/demo_transcribe.py")
    sys.exit(1)

# Override engine and SessionLocal for this script to ensure in-memory SQLite is used
# This is done *after* app.db is imported but before Base.metadata.create_all
engine = create_engine(
    "sqlite:///:memory:",
    echo=False, # Quieter for demo
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
SessionLocal = sessionmaker(bind=engine)
Base.metadata.bind = engine # Rebind Base to the new in-memory engine

# Check if audio_cache directory exists
if not os.path.exists(AUDIO_DIR):
    print(f"Creating audio cache directory: {AUDIO_DIR}")
    os.makedirs(AUDIO_DIR, exist_ok=True)

# Ensure tables exist on the in-memory DB
Base.metadata.create_all(bind=engine)

# Insert a demo recording (change port if needed)
server_port = 8001  # Change this if your server is on a different port
db = SessionLocal()
meeting_id_for_demo = "demo_meeting_summary_123"

recording = db.query(Recording).filter_by(meeting_id=meeting_id_for_demo).first()
if not recording:
    print(f"Creating new recording: {meeting_id_for_demo}")
    recording = Recording(
        platform="test_summary_demo",
        meeting_id=meeting_id_for_demo,
        recording_url=f"http://localhost:{server_port}/sample.mp4" # Make sure sample.mp4 is served
    )
    db.add(recording)
    db.commit()
else:
    print(f"Using existing recording: {meeting_id_for_demo}. Clearing transcript/summary for re-run.")
    recording.transcript_fetched = False
    recording.transcript_path = None
    recording.summary = None
    db.commit()

# Cache the ID before closing the session for insert/update
db_meeting_id = recording.meeting_id
db_recording_id = recording.id
db.close()

# Run the transcription and summarization pipeline
print(f"Running transcription & summarization job for {db_meeting_id}...")
try:
    run_transcription_job() # This now includes summarization
except Exception as e:
    print(f"Error during transcription/summarization: {e}")
    print("\nMake sure:")
    print(f"1. HTTP server is running: python3 -m http.server {server_port} --directory docs/assets")
    print("2. sample.mp4 exists in docs/assets")
    print("3. ffmpeg is installed (e.g., brew install ffmpeg or sudo apt-get install ffmpeg)")
    print("4. OPENAI_API_KEY is set in your .env file for real summaries, or a dummy is used.")
    sys.exit(1)

# Re-fetch the recording to get the summary
db = SessionLocal()
final_recording = db.query(Recording).filter_by(id=db_recording_id).first()
db.close()

# Locate and print the transcript and summary
transcript_file = AUDIO_DIR / f"{db_meeting_id}.json"
print(f"\nTranscript JSON path: {transcript_file}")

if transcript_file.exists():
    try:
        transcript_data = json.loads(transcript_file.read_text())
        print("Transcription successful!")
        print(f"Transcript text (first 200 chars):\n{transcript_data.get('text', '<no text key>')[:200]}...")
    except Exception as e:
        print(f"Error reading transcript file: {e}")
else:
    print("\nERROR: Transcript file not found.")

if final_recording and final_recording.summary:
    print("\nSummary generation successful!")
    print(f"Summary:\n{final_recording.summary}")
elif final_recording:
    print(f"\nSummary not found for {final_recording.meeting_id}. Check logs for errors.")
else:
    print("\nERROR: Final recording object not found after processing.")

print("\nDemo script finished.") 